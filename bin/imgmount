#!/bin/bash
# Version of this script. Use in usage statements and version tracking.
VERSION=0.1
# This script's full path name.
SCRIPT_FULLPATH="$(readlink -f $0)"
# This script's absolute directory (without trailing slash).
SCRIPT_DIR="$(dirname $SCRIPT_FULLPATH)"
# This script's base name (file name only, without directory).
SCRIPT_NAME="$(basename $SCRIPT_FULLPATH)"
# Path to ansilib.sh, which supports color text output.
ANSILIB_PATH=/usr/local/lib/ansilib.sh
# Aliases to include caller line number in message functions.
shopt -s expand_aliases
alias info='info_msg $LINENO'
alias warn='warn_msg $LINENO'
alias error='error_msg $LINENO'
alias fatal='fatal_msg $LINENO'

timestamp() { date +"%Y-%m-%d %H:%M:%S"; }

printc() {
	# Output a text with given color as the first argument if supported.
	# If the first agument is not a valid foreground color, print everything.
	# If color is not supported, print without color.
	if [ -z "$ANSI_FOREGROUNDS" ]; then
		shift
		echo "$*"
		return
	fi

	local valid=
	for c in $ANSI_FOREGROUNDS; do if [ "$c" == "$1" ]; then valid=true; fi; done

	if [ -n "$valid" ]; then 
		text_color=$1
		shift
		if [ -n "$color" ]; then
			echo "$($text_color "$*")"
		else
			echo "$*"
		fi
	else
		# Invalid color? Print all.
		echo "$*"
	fi
}

printb() {
	# Output a text with text and background color in the first 2 arguments.
	# If the first agument is not a valid foreground color, print everything.
	# If the second agument is not a valid background color, print with 
	# foreground.
	# If color is not supported, print without color.
	if [ -z "$ANSI_FOREGROUNDS" ]; then
		shift 2
		echo "$*"
		return
	fi

	local valid=
	# Validate foreground.
	for c in $ANSI_FOREGROUNDS; do if [ "$c" == "$1" ]; then valid=true; fi; done
	if [ -n "$valid" ]; then 
		text_color=$1
		shift
		# Validate background.
		valid=
		for c in $ANSI_BACKGROUNDS; do if [ "$c" == "$1" ]; then valid=true; fi; done
		if [ -n "$valid" ]; then
			bg_color=$1
			shift
			# All well? Print with both foreground and background.
			if [ -n "$color" ]; then
				echo "$($text_color "$(${bg_color}_bg "$*")")"
			else
				echo "$*"
			fi
		else
			# Invalid background? Print just foreground then.
			if [ -n "$color" ]; then
				echo "$($text_color "$*")"
			else
				echo "$*"
			fi
		fi
	else
		# Invalid color? Print all.
		echo "$*"
	fi
}

info_msg() {
	# Print an info message. Caller line number is the first argument.
	line=$1
	shift
	if [ -z "$color" ]; then
		>&2 echo "$(timestamp) INFO  ($SCRIPT_NAME:$line): $*"
	else
		>&2 echo "$(timestamp) INFO  ($(green $SCRIPT_NAME:$line)): $*"
	fi
}

warn_msg() {
	# Print an warning message. Caller line number is the first argument.
	line=$1
	shift
	if [ -z "$color" ]; then
		>&2 echo "$(timestamp) WARN  ($SCRIPT_NAME:$line): $*"
	else
		>&2 echo "$(timestamp) $(yellow WARN)  ($(green $SCRIPT_NAME:$line)): $*"
	fi
}

error_msg() {
	# Print an error message. Caller line number is the first argument.
	line=$1
	shift
	if [ -z "$color" ]; then
		>&2 echo "$(timestamp) ERROR ($SCRIPT_NAME:$line): $*"
	else
		>&2 echo "$(timestamp) $(red ERROR) ($(green $SCRIPT_NAME:$line)): $*"
	fi
}

fatal_msg() {
	# Print an fatal message then quit. Caller line number is the first argument,
	# and the second is the exit code.
	line=$1
	code=$2
	shift 2
	if [ -z "$color" ]; then
		>&2 echo "$(timestamp) FATAL ($SCRIPT_NAME:$line, code $code): $*"
	else
		>&2 echo "$(timestamp) $(purple FATAL) ($(green $SCRIPT_NAME:$line, $(purple code $code))): $*"
	fi
	exit $code
}

# Include ansilib and enable color support if possible.
if [ -f $ANSILIB_PATH ]; then
	color=yes
	. $ANSILIB_PATH
fi

# A fuction to print usage statements. Usage statements might be printed more
# than once, so it's better to make it a function.
print_usage () {
	# Usage statements, use heredoc. Put all statements between "USAGE" lines.
	if [ -z "$color" ]; then
		cat <<-USAGE
			$SCRIPT_NAME version $VERSION.
			Mount/unmount disk/partition image.
			Syntax: $SCRIPT_NAME [options] image dir
			Options:
			image           Path to the image.
			dir             Mount point (a directory).
			-h              Print this usage.
			-p n            Mount the "n"th partition in the image. Default is 1.
			-r              Mount in read-only mode.
			-v              Print this program version.
			USAGE
	else
		cat <<-COLORUSAGE
			$(ugreen $SCRIPT_NAME) version $(red $(yellow_bg $VERSION)).
			Say hello to given name and print out all given command line arguments.
			Syntax: $(green $SCRIPT_NAME) $(yellow [options])
			$(yellow Options:)
			image           Path to the image.
			dir             Mount point (a directory).
			-h              Print this usage.
			-p n            Mount the "n"th partition in the image. Default is 1.
			-r              Mount in read-only mode.
			-v              Print this program version.
			COLORUSAGE
	fi
}

# Check the number of given command line arguments.
if [[ $# -eq 0 ]]; then
	# No argument? Print a reminder.
	print_usage
	exit
fi

# Now handle command line option based on predefined list. Refer to "getopts"
# document to understand this code.
while getopts ":hp:rv" opt; do
	case ${opt} in
	h) print_usage; exit ;;
	p) part_no=$OPTARG ;;
	r) read_only='-r' ;;
	v) echo $SCRIPT_NAME version $VERSION; exit ;;
	\?) fatal 1 "Invalid option \"$OPTARG\"" ;;
	:) fatal 2 "Option \"$OPTARG\" requires an argument." ;;
	esac
done

# Remove processed arguments.
shift $((OPTIND-1))

fuck() {
	echo "$1"
}

# This script must be run as root/sudo.
if [ $(id -u) -ne 0 ]; then
	fatal 3 Require root/sudo privilege.
fi

# Check image file.
if [ $# -lt 2 ]; then
	fatal 4 Missing image file and/or mount point.
elif [ ! -f "$1" ]; then
	fatal 5 \"$1\" is not a file.
else
	img=$1
	dir=$2
	if [ ! -d "$dir" ]; then
		info \"$dir\" does not exist. Creating it...
		mkdir -p "$dir"
	fi
fi

# Analyze the image.
echo Analyzing image...
IFS=$'
'
parts=($(fdisk -l $img | grep -e "^Sector size" -e "^Device" -e "^$img"))

if [ ${#parts[@]} -lt 3 ]; then
	fatal 6 "This is not a valid image."
fi

n=0
for part in ${parts[@]}; do
	if [ $n -eq 0 ]; then
		sector_size=$(awk '{print $4}' <<<"$part")
		echo "Sector size: $sector_size bytes"
	elif [ $n -eq 1 ]; then
		IFS=' ' printc hwhite "Partitions list:"
		IFS=' ' printc uwhite "# $part           "
	else
		IFS=' ' echo "$((n - 1)) $part"
	fi
	let n+=1
done
unset IFS

if [[ -n "$part_no" && $part_no -gt 0 && $part_no -lt $((${#parts[@]} - 1)) ]]; then
	part=${parts[$((part_no + 1))]}
else
	# Ask for target partition.
	while true; do
		last=$((${#parts[@]} - 2))
		prompt="$(printc yellow Which partition to mount \(1-$last, Ctrl-C to cancel\)?) "
		read -r -p "$prompt" part_no
		if [[ $part_no -ge 1 && $part_no -le $last ]]; then
			part=${parts[$((part_no + 1))]}
			break
		else
			echo $part_no is invalid. Please choose again.
		fi
	done
fi

if [ -z "$read_only" ]; then
	printc Will mount partiton $(printc yellow $part_no) from $(printc hblue $img) to $(printc hblue $dir)
else
	printc Will mount $(printc yellow read-only) partiton $(printc yellow $part_no) from $(printc hblue $img) to $(printc hblue $dir)
fi

# Find a free loop device.
dev=$(losetup -f)
first_sector=$(awk '{print $2}' <<<"$part")
offset=$(($sector_size * $first_sector))
# echo Attaching partition $part_no from sector $first_sector, offset $offset to $dev
losetup -o $offset /dev/loop0 $img
if [ $? -ne 0 ]; then
	fatal 6 Failed to attach.
fi
mount $read_only /dev/loop0 $dir
if [ $? -ne 0 ]; then
	fatal 7 Failed to mount.
fi
# printc green "Mounted to $(hblue $dir). You can start using it now."
printc green "Mounted to $dir. You can start using it now."
printc yellow "NOTE: Run \"sudo umount $dev\" then \"sudo losetup -d $dev\"" to detach.
