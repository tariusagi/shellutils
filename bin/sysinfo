#!/bin/bash
# Version of this script. Use in usage statements and version tracking.
VERSION=0.1
# This script's full path name.
SCRIPT=$(readlink -f $0)
# This script's absolute directory (without trailing slash).
SCRIPT_DIR="$(dirname $SCRIPT)"
# This script's base name (file name only, without directory).
SCRIPT_NAME=$(basename $SCRIPT)

function show() {
	echo $*
	# Display on LCD server if $LCD_SERVER was defined.
	if [ -n "$lcd" ]; then
		echo line${line} ${name:-$(hostname)}: $* | nc -w1 $lcd $port
		test -n "$interval" && sleep $interval || sleep 1
	else
		test -n "$interval" && sleep $interval
	fi
}

function get_ips() {
	local SHOW_IP_PATTERN="^[ewr].*|^br.*|^lt.*|^umts.*|^lan.*"
	local ips=()

	for f in /sys/class/net/*; do
		local intf=$(basename $f)
		if [[ $intf =~ $SHOW_IP_PATTERN ]]; then
			# Match only interface names starting with e (Ethernet), br (bridge), 
			# w (wireless), r (some Ralink drivers use ra<number> format)
			local tmp=$(ip -4 addr show dev $intf | awk '/inet/ {print $2}' | cut -d'/' -f1)
			[[ -n $tmp ]] && ips+=("$tmp")
		fi
	done

	echo ${ips[@]}
}

function get_cpu_stat() {
	local load=$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1"%"}')
	if [ -f /sys/class/thermal/thermal_zone0/temp ]; then
		local temp=$(($(cat /sys/class/thermal/thermal_zone0/temp)/1000))
	else
		local temp=??
	fi
	echo CPU $load ${temp}oC
}

function get_root_usage() {
	local root_info=$(df -h /)
	local usage=$(awk '/\// {print $(NF-1)}' <<<${root_info} | sed 's/%//g')
	local total=$(awk '/\// {print $(NF-4)}' <<<${root_info})
	echo Root $(df -h | awk '$NF == "/" {s=$3"/"$2; gsub("G", "", s); print s"G"}') 
}

function get_mem_usage() {
	echo Mem $(free -mw | awk '$1 == "Mem:" {print $3"/"$2"M"}') 
}

function get_uptime() {
	local UPTIME=$(LC_ALL=C uptime)
	local UPT1=${UPTIME#*'up '}
	local UPT2=${UPT1%'user'*}
	time=${UPT2%','*}
	time=${time//','}

	echo Up $time
}

function show_all() {
	echo System info:
	echo ------------
	local ips=($(get_ips))
	# There can be multiple IPs. Show all of them one by one.
	for ip in "${ips[@]}"; do
		show $ip
	done
	show $(get_cpu_stat)
	show $(get_mem_usage)
	show $(get_root_usage)
	show $(get_uptime)
}

function on_exit() {
	show "Info N/A"
	exit
}

print_usage () {
	# Usage statements, use heredoc. Put all statements between "USAGE" lines.
	cat <<-USAGE
	$SCRIPT_NAME version $VERSION.
	Syntax: $SCRIPT_NAME [OPTIONS]
	Print system info one by one and optionally show on a LCD.
	Options:
	-h            Print this usage.
	-i sec        Seconds between metrics. Default none or 1 if show on a LCD.
	-n name       Name of the system. Default is the hostname.
	-r            Repeat.
	-s host       Address of a LCD server.
	-p port       Port of a LCD server. Default is 1234.
	-l num        Line to be printed on the LCD.
	USAGE
}

# Default settings.
line=1
export port=1234

# Now handle command line arguments based on predefined list. Refer to "getopts"
# document to understand this code.
while getopts "hi:l:n:p:rs:" opt; do
	case ${opt} in
	h ) print_usage; exit ;;
	i ) interval=$OPTARG ;;
	l ) line=$OPTARG ;;
	n ) name=$OPTARG ;;
	p ) port=$OPTARG ;;
	r ) repeat=True ;;
	s ) lcd=$OPTARG ;;
	\? )echo "ERROR: Invalid option \"$OPTARG\""; exit 2 ;;
	: ) echo "ERROR: Option \"$OPTARG\" requires an argument."; exit 3 ;;
	esac
done

if [ -n "$repeat" ]; then
	# Repeat.
	trap on_exit INT TERM
	while true; do
		show_all
	done
else
	show_all
fi
